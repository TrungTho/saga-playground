
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/TrungTho/saga-playground/api/orders.go (90.9%)</option>
				
				<option value="file1">github.com/TrungTho/saga-playground/api/response.go (85.7%)</option>
				
				<option value="file2">github.com/TrungTho/saga-playground/api/server.go (71.4%)</option>
				
				<option value="file3">github.com/TrungTho/saga-playground/cmd/server/main.go (0.0%)</option>
				
				<option value="file4">github.com/TrungTho/saga-playground/cmd/worker/main.go (0.0%)</option>
				
				<option value="file5">github.com/TrungTho/saga-playground/db/mock/dbstore.go (69.6%)</option>
				
				<option value="file6">github.com/TrungTho/saga-playground/db/mock/querier.go (0.0%)</option>
				
				<option value="file7">github.com/TrungTho/saga-playground/db/sqlc/db.go (50.0%)</option>
				
				<option value="file8">github.com/TrungTho/saga-playground/db/sqlc/dbstore.go (81.8%)</option>
				
				<option value="file9">github.com/TrungTho/saga-playground/db/sqlc/models.go (41.2%)</option>
				
				<option value="file10">github.com/TrungTho/saga-playground/db/sqlc/orders.sql.go (88.0%)</option>
				
				<option value="file11">github.com/TrungTho/saga-playground/db/sqlc/ordertx.go (87.5%)</option>
				
				<option value="file12">github.com/TrungTho/saga-playground/db/sqlc/setup.go (70.0%)</option>
				
				<option value="file13">github.com/TrungTho/saga-playground/grpc_server/orders.go (100.0%)</option>
				
				<option value="file14">github.com/TrungTho/saga-playground/grpc_server/server.go (66.7%)</option>
				
				<option value="file15">github.com/TrungTho/saga-playground/logger/init.go (0.0%)</option>
				
				<option value="file16">github.com/TrungTho/saga-playground/pb/order.pb.go (23.8%)</option>
				
				<option value="file17">github.com/TrungTho/saga-playground/pb/order_grpc.pb.go (0.0%)</option>
				
				<option value="file18">github.com/TrungTho/saga-playground/redis/init.go (0.0%)</option>
				
				<option value="file19">github.com/TrungTho/saga-playground/util/config.go (100.0%)</option>
				
				<option value="file20">github.com/TrungTho/saga-playground/util/random.go (100.0%)</option>
				
				<option value="file21">github.com/TrungTho/saga-playground/util/test.go (100.0%)</option>
				
				<option value="file22">github.com/TrungTho/saga-playground/worker/subscriber/checkout.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "fmt"
        "log/slog"
        "math/big"
        "strconv"

        "github.com/TrungTho/saga-playground/constants"
        db "github.com/TrungTho/saga-playground/db/sqlc"
        "github.com/TrungTho/saga-playground/util"
        "github.com/gin-gonic/gin"
        "github.com/jackc/pgx/v5/pgtype"
        "github.com/jinzhu/copier"
)

type CreateOrderRequest struct {
        UserId string `json:"user_id" binding:"required"`
}

// DTO for hiding some fields from DB (maybe in the future)
type CreateOrderResponse struct {
        ID int32 `json:"id"`
        // random value, not used now
        UserID string         `json:"user_id"`
        Status db.OrderStatus `json:"status"`
        Amount pgtype.Numeric `json:"amount"`
        // for failed reason
        Message *string `db:"message" json:"message"`
}

func (server *RestServer) createOrder(ctx *gin.Context) <span class="cov10" title="3">{
        var req CreateOrderRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                responseBadRequest(ctx, err.Error())
                return
        }</span>

        <span class="cov6" title="2">logFields := slog.Group("request",
                slog.String("URL", ctx.Request.URL.Path),
                slog.Any("Body", ctx.Request.Body),
        )

        // auth is skipped in order to focus on business logic of this playground
        fakeAmount := float64(util.RandomInt(1, 100)) + util.RandomFloat(1)

        args := db.CreateOrderParams{
                UserID: req.UserId,
                Status: db.OrderStatusCreated,
        }

        args.Amount = pgtype.Numeric{
                Int:   big.NewInt(int64(fakeAmount * 100)),
                Exp:   -2,
                Valid: true,
        }

        createdOrder, err := server.dbStore.CreateOrder(ctx, args)
        if err != nil </span><span class="cov1" title="1">{
                slog.ErrorContext(ctx, constants.ERROR_ORDER_CREATE_FAILED, slog.Any("error", err))
                responseInternalServer(ctx, err.Error())
                return
        }</span>

        <span class="cov1" title="1">var resp CreateOrderResponse
        err = copier.Copy(&amp;resp, &amp;createdOrder)
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, constants.ERROR_ORDER_DTO_CONVERT, logFields)
        }</span>

        <span class="cov1" title="1">slog.InfoContext(ctx, constants.ORDER_CREATED, logFields,
                slog.Any("order", createdOrder))

        responseSuccess(ctx, resp)</span>
}

func (server *RestServer) getOrder(ctx *gin.Context) <span class="cov10" title="3">{
        logFields := slog.Group("request",
                slog.String("URL", ctx.Request.URL.Path),
        )

        id := ctx.Param("id")
        orderId, err := strconv.Atoi(id)
        if err != nil </span><span class="cov1" title="1">{
                errStr := fmt.Sprintf("Can not parse order id, got %v", id)
                slog.ErrorContext(ctx, errStr, logFields, "error", err)
                responseBadRequest(ctx, errStr)
                return
        }</span>

        <span class="cov6" title="2">order, err := server.dbStore.GetOrder(ctx, int32(orderId))
        if err != nil </span><span class="cov1" title="1">{
                slog.ErrorContext(ctx, constants.ERROR_ORDER_NOT_FOUND, slog.Any("error", err))
                responseNotFound(ctx, err.Error())
                return
        }</span>

        <span class="cov1" title="1">var resp CreateOrderResponse
        err = copier.Copy(&amp;resp, &amp;order)
        if err != nil </span><span class="cov0" title="0">{
                errStr := fmt.Sprintf("Can not clone order from %v", order)
                slog.ErrorContext(ctx, errStr, logFields)
                responseBadRequest(ctx, errStr)
                return
        }</span>

        <span class="cov1" title="1">responseSuccess(ctx, resp)</span>
}

func (server *RestServer) cancelOrder(ctx *gin.Context) <span class="cov10" title="3">{
        logFields := slog.Group("request",
                slog.String("URL", ctx.Request.URL.Path),
                slog.Any("Body", ctx.Request.Body),
        )

        id := ctx.Param("id")
        orderId, err := strconv.Atoi(id)
        if err != nil </span><span class="cov1" title="1">{
                errStr := fmt.Sprintf("Can not parse order id, got %v", id)
                slog.ErrorContext(ctx, errStr, logFields, "error", err)
                responseBadRequest(ctx, errStr)
                return
        }</span>

        <span class="cov6" title="2">_, err = server.dbStore.CancelOrderTx(ctx, orderId, logFields)
        if err != nil </span><span class="cov1" title="1">{
                slog.ErrorContext(ctx, constants.ERROR_ORDER_CANCEL_FAILED, slog.Any("error", err))
                responseBadRequest(ctx, err.Error())
                return
        }</span>

        <span class="cov1" title="1">slog.InfoContext(ctx, constants.ORDER_CANCELLED, logFields)

        responseNoContent(ctx)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "log/slog"
        "net/http"

        "github.com/TrungTho/saga-playground/constants"
        "github.com/gin-gonic/gin"
)

// RestResponse api response struct
type RestResponse struct {
        Code int         `json:"code"` // just in case in the future we need more than just a http code to evaluate the response (from client side)
        Msg  string      `json:"msg"`
        Data interface{} `json:"data"`
}

func newResponse(code int, msg string, data interface{}) *RestResponse <span class="cov10" title="10">{
        return &amp;RestResponse{
                Code: code,
                Msg:  msg,
                Data: data,
        }
}</span>

func responseSuccess(c *gin.Context, data interface{}) <span class="cov5" title="3">{
        resp := newResponse(http.StatusOK, constants.OK, data)

        c.JSON(http.StatusOK, resp)
}</span>

func responseNoContent(c *gin.Context) <span class="cov1" title="1">{
        resp := newResponse(http.StatusNoContent, constants.OK, nil)

        c.JSON(http.StatusNoContent, resp)
}</span>

func responseError(c *gin.Context, errCode int, err error, extras ...string) <span class="cov0" title="0">{
        resp := newResponse(
                errCode,
                err.Error(),
                nil,
        )

        c.JSON(errCode, resp)
}</span>

func responseInternalServer(c *gin.Context, err string) <span class="cov1" title="1">{
        slog.ErrorContext(c, constants.ERROR_INTERNAL, slog.Group("request",
                slog.String("url", c.Request.RequestURI),
                slog.String("method", c.Request.Method),
                slog.Any("body", c.Request.Body),
                slog.String("error", err),
        ),
        )

        resp := newResponse(http.StatusInternalServerError, err, nil)

        c.JSON(http.StatusInternalServerError, resp)
}</span>

func responseBadRequest(c *gin.Context, err string) <span class="cov6" title="4">{
        resp := newResponse(http.StatusBadRequest, constants.ERROR_BAD_REQUEST, err)

        c.JSON(http.StatusBadRequest, resp)
}</span>

func responseNotFound(c *gin.Context, err string) <span class="cov1" title="1">{
        resp := newResponse(http.StatusNotFound, constants.ERROR_NOT_FOUND, err)

        c.JSON(http.StatusNotFound, resp)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "context"
        "log"
        "net/http"

        db "github.com/TrungTho/saga-playground/db/sqlc"
        "github.com/gin-gonic/gin"
)

type RestServer struct {
        router  *gin.Engine
        dbStore db.DBStore
        server  *http.Server
}

// NewServer creates a new HTTP server and set up routing.
func NewServer(dbStore db.DBStore) (*RestServer, error) <span class="cov10" title="10">{
        server := &amp;RestServer{
                dbStore: dbStore,
        }

        server.setupRouter()
        return server, nil
}</span>

func (server *RestServer) setupRouter() <span class="cov10" title="10">{
        router := gin.Default()

        // health check endpoint
        router.GET("/ping", func(ctx *gin.Context) </span><span class="cov1" title="1">{
                responseSuccess(ctx, "pong")
        }</span>)

        <span class="cov10" title="10">router.POST("/orders", server.createOrder)
        router.GET("/orders/:id", server.getOrder)
        router.DELETE("/orders/:id", server.cancelOrder)

        server.router = router</span>
}

// Start runs the HTTP server on a specific address.
func (s *RestServer) Start(address string) error <span class="cov0" title="0">{
        log.Default().Printf("Start REST server at %v", address)

        s.server = &amp;http.Server{
                Addr:    address,
                Handler: s.router.Handler(),
        }

        return s.server.ListenAndServe()
}</span>

// Start runs the HTTP server on a specific address.
func (s *RestServer) Stop() error <span class="cov0" title="0">{
        return s.server.Shutdown(context.Background()) // unlimited time
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "context"
        "errors"
        "fmt"
        "log"
        "log/slog"
        "net"
        "net/http"
        "os"
        "os/signal"
        "syscall"

        "github.com/TrungTho/saga-playground/api"
        db "github.com/TrungTho/saga-playground/db/sqlc"
        "github.com/TrungTho/saga-playground/grpc_server"
        "github.com/TrungTho/saga-playground/logger"
        "github.com/TrungTho/saga-playground/pb"
        "github.com/TrungTho/saga-playground/util"
        "github.com/jackc/pgx/v5/pgxpool"
        "golang.org/x/sync/errgroup"
        "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"
)

func main() <span class="cov0" title="0">{
        // load config from env file
        config := loadConfig()

        // init logger
        logger.InitLogger()

        // init db connection
        dbStores, db := initDbConnection(&amp;config)
        defer db.Close()

        // block until you are ready to shut down
        ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGSEGV, syscall.SIGINT)
        defer stop()

        wg, ctx := errgroup.WithContext(ctx)

        // init rest server configuration
        restServer := initRestServer(dbStores)

        // start rest server
        startRestServer(ctx, wg, restServer, config)

        // init rest gRPC server configuration
        gRPCServer := initGRPCServer(dbStores)

        // start grpc server
        startGRPCServer(ctx, wg, gRPCServer, config)

        err := wg.Wait()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("failed to start servers", err)
        }</span>

        // graceful shutdown and clean resources if needed
        <span class="cov0" title="0">log.Println("==============================")
        log.Println("Finished shutting down servers")
        log.Println("==============================")</span>
}

func startGRPCServer(ctx context.Context,
        wg *errgroup.Group,
        logicServer *grpc_server.GRPCServer,
        config util.Config,
) <span class="cov0" title="0">{
        grpcServer := grpc.NewServer()
        pb.RegisterOrderServiceServer(grpcServer, logicServer) // register the "logic server", which implement all the needed functions of generated interfaces - logicServer, with the shell, actual, skeleton gRPC server to serve incoming traffic - grpcServer (grpc.NewServer)

        reflection.Register(grpcServer) // auto explore all defined grpc functions we implement inside of gRPCServer

        wg.Go(func() error </span><span class="cov0" title="0">{
                grpcAddress := fmt.Sprintf("%s:%s",
                        config.ORDER_SERVICE_HOST, config.ORDER_SERVICE_GRPC_PORT)

                log.Printf("Start gRPC server at %v\n", grpcAddress)
                lis, err := net.Listen("tcp", grpcAddress)
                if err != nil &amp;&amp; !errors.Is(err, grpc.ErrServerStopped) </span><span class="cov0" title="0">{
                        slog.Error("grpc server failed to listen")
                        return err
                }</span>

                <span class="cov0" title="0">err = grpcServer.Serve(lis)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Error("grpc server failed to start")
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">wg.Go(func() error </span><span class="cov0" title="0">{
                &lt;-ctx.Done()

                slog.InfoContext(ctx, "Shutting down grpc server...")
                grpcServer.GracefulStop()
                slog.InfoContext(ctx, "gRPC server is completely shutdown!")

                return nil
        }</span>)
}

func startRestServer(ctx context.Context,
        wg *errgroup.Group,
        restServer *api.RestServer,
        config util.Config,
) <span class="cov0" title="0">{
        wg.Go(func() error </span><span class="cov0" title="0">{
                err := restServer.Start(fmt.Sprintf("%s:%s",
                        config.ORDER_SERVICE_HOST, config.ORDER_SERVICE_PORT))
                if err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        log.Fatalln("Can not start Rest Server ", err)
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">wg.Go(func() error </span><span class="cov0" title="0">{
                &lt;-ctx.Done()

                slog.InfoContext(ctx, "Shutting down rest server...")
                err := restServer.Stop()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalln("Can not stop Rest Server ", err)
                        return err
                }</span>

                <span class="cov0" title="0">slog.InfoContext(ctx, "RESTful server is completely shutdown!")
                return nil</span>
        })
}

func initRestServer(dbStore db.DBStore) *api.RestServer <span class="cov0" title="0">{
        restServer, err := api.NewServer(dbStore)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln("Can not create new Rest Server ", err)
        }</span>
        <span class="cov0" title="0">return restServer</span>
}

func initGRPCServer(dbStore db.DBStore) *grpc_server.GRPCServer <span class="cov0" title="0">{
        gRPCServer, err := grpc_server.NewServer(dbStore)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln("Can not create new gRPC Server ", err)
        }</span>
        <span class="cov0" title="0">return gRPCServer</span>
}

func initDbConnection(config *util.Config) (db.DBStore, *pgxpool.Pool) <span class="cov0" title="0">{
        dbStore, db := db.SetupDBConnection(config)

        if dbStore == nil </span><span class="cov0" title="0">{
                log.Fatalln("Can not establish DB connection")
        }</span>
        <span class="cov0" title="0">return dbStore, db</span>
}

func loadConfig() util.Config <span class="cov0" title="0">{
        config, err := util.LoadConfig("./../../.env")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln("Can not load config from env ", err)
        }</span>
        <span class="cov0" title="0">return config</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "fmt"
        "log"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/TrungTho/saga-playground/logger"
        "github.com/go-co-op/gocron/v2"
)

func main() <span class="cov0" title="0">{
        // init logger
        logger.InitLogger()

        // create a scheduler
        s, err := gocron.NewScheduler()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to init gocron scheduler %v", err)
        }</span>

        // for signal termination
        <span class="cov0" title="0">signChan := make(chan os.Signal, 1)

        // add a job to the scheduler
        registerFinishedCheckoutMessagePulling(s)

        // start the scheduler
        go func() </span><span class="cov0" title="0">{
                s.Start()
                log.Println("Successfully start worker!!!")
        }</span>()

        // block until you are ready to shut down
        <span class="cov0" title="0">signal.Notify(signChan, os.Interrupt, syscall.SIGTERM, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGSEGV, syscall.SIGINT)
        &lt;-signChan

        // graceful shutdown and clean resources if needed
        log.Println("Start shutting down workers...")
        log.Printf("Number of active jobs: %v - number of in-queue jobs %v\n", len(s.Jobs()), s.JobsWaitingInQueue())
        err = s.Shutdown()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to stop scheduler %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Finished shutting down workers!!!")
        close(signChan)</span>
}

func registerFinishedCheckoutMessagePulling(s gocron.Scheduler) <span class="cov0" title="0">{
        j, err := s.NewJob(
                gocron.DurationJob(
                        1*time.Second,
                ),
                gocron.NewTask(
                        func() </span><span class="cov0" title="0">{
                                log.Println("start job")
                                time.Sleep(10 * time.Second)
                                log.Println("finished job")
                        }</span>,
                ),
                gocron.WithSingletonMode(gocron.LimitModeReschedule),
        )
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to add job %v to scheduler %v", j.ID(), err)
        }</span>

        // each job has a unique id
        <span class="cov0" title="0">fmt.Println("ID of job:", j.ID())</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./db/sqlc/ (interfaces: DBStore)
//
// Generated by this command:
//
//        mockgen -destination ./db/mock/dbstore.go ./db/sqlc/ DBStore
//

// Package mock_db is a generated GoMock package.
package mock_db

import (
        context "context"
        slog "log/slog"
        reflect "reflect"

        db "github.com/TrungTho/saga-playground/db/sqlc"
        gomock "go.uber.org/mock/gomock"
)

// MockDBStore is a mock of DBStore interface.
type MockDBStore struct {
        ctrl     *gomock.Controller
        recorder *MockDBStoreMockRecorder
        isgomock struct{}
}

// MockDBStoreMockRecorder is the mock recorder for MockDBStore.
type MockDBStoreMockRecorder struct {
        mock *MockDBStore
}

// NewMockDBStore creates a new mock instance.
func NewMockDBStore(ctrl *gomock.Controller) *MockDBStore <span class="cov10" title="11">{
        mock := &amp;MockDBStore{ctrl: ctrl}
        mock.recorder = &amp;MockDBStoreMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDBStore) EXPECT() *MockDBStoreMockRecorder <span class="cov10" title="11">{
        return m.recorder
}</span>

// CancelOrderTx mocks base method.
func (m *MockDBStore) CancelOrderTx(ctx context.Context, orderId int, logFields slog.Attr) (int, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CancelOrderTx", ctx, orderId, logFields)
        ret0, _ := ret[0].(int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CancelOrderTx indicates an expected call of CancelOrderTx.
func (mr *MockDBStoreMockRecorder) CancelOrderTx(ctx, orderId, logFields any) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CancelOrderTx", reflect.TypeOf((*MockDBStore)(nil).CancelOrderTx), ctx, orderId, logFields)
}</span>

// CreateOrder mocks base method.
func (m *MockDBStore) CreateOrder(ctx context.Context, arg db.CreateOrderParams) (db.Order, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateOrder", ctx, arg)
        ret0, _ := ret[0].(db.Order)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateOrder indicates an expected call of CreateOrder.
func (mr *MockDBStoreMockRecorder) CreateOrder(ctx, arg any) *gomock.Call <span class="cov5" title="3">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrder", reflect.TypeOf((*MockDBStore)(nil).CreateOrder), ctx, arg)
}</span>

// GetOrder mocks base method.
func (m *MockDBStore) GetOrder(ctx context.Context, id int32) (db.Order, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetOrder", ctx, id)
        ret0, _ := ret[0].(db.Order)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetOrder indicates an expected call of GetOrder.
func (mr *MockDBStoreMockRecorder) GetOrder(ctx, id any) *gomock.Call <span class="cov6" title="4">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrder", reflect.TypeOf((*MockDBStore)(nil).GetOrder), ctx, id)
}</span>

// ListOrders mocks base method.
func (m *MockDBStore) ListOrders(ctx context.Context, arg db.ListOrdersParams) ([]db.Order, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListOrders", ctx, arg)
        ret0, _ := ret[0].([]db.Order)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListOrders indicates an expected call of ListOrders.
func (mr *MockDBStoreMockRecorder) ListOrders(ctx, arg any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListOrders", reflect.TypeOf((*MockDBStore)(nil).ListOrders), ctx, arg)
}</span>

// UpdateOrderStatus mocks base method.
func (m *MockDBStore) UpdateOrderStatus(ctx context.Context, arg db.UpdateOrderStatusParams) (db.Order, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateOrderStatus", ctx, arg)
        ret0, _ := ret[0].(db.Order)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateOrderStatus indicates an expected call of UpdateOrderStatus.
func (mr *MockDBStoreMockRecorder) UpdateOrderStatus(ctx, arg any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateOrderStatus", reflect.TypeOf((*MockDBStore)(nil).UpdateOrderStatus), ctx, arg)
}</span>

// ValidateAndUpdateOrderStatusTx mocks base method.
func (m *MockDBStore) ValidateAndUpdateOrderStatusTx(ctx context.Context, id int, expectedCurrentStatus, newStatus db.OrderStatus, logFields slog.Attr) (int, error) <span class="cov3" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ValidateAndUpdateOrderStatusTx", ctx, id, expectedCurrentStatus, newStatus, logFields)
        ret0, _ := ret[0].(int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ValidateAndUpdateOrderStatusTx indicates an expected call of ValidateAndUpdateOrderStatusTx.
func (mr *MockDBStoreMockRecorder) ValidateAndUpdateOrderStatusTx(ctx, id, expectedCurrentStatus, newStatus, logFields any) *gomock.Call <span class="cov3" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateAndUpdateOrderStatusTx", reflect.TypeOf((*MockDBStore)(nil).ValidateAndUpdateOrderStatusTx), ctx, id, expectedCurrentStatus, newStatus, logFields)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./db/sqlc/ (interfaces: Querier)
//
// Generated by this command:
//
//        mockgen -destination ./db/mock/querier.go ./db/sqlc/ Querier
//

// Package mock_db is a generated GoMock package.
package mock_db

import (
        context "context"
        reflect "reflect"

        db "github.com/TrungTho/saga-playground/db/sqlc"
        gomock "go.uber.org/mock/gomock"
)

// MockQuerier is a mock of Querier interface.
type MockQuerier struct {
        ctrl     *gomock.Controller
        recorder *MockQuerierMockRecorder
        isgomock struct{}
}

// MockQuerierMockRecorder is the mock recorder for MockQuerier.
type MockQuerierMockRecorder struct {
        mock *MockQuerier
}

// NewMockQuerier creates a new mock instance.
func NewMockQuerier(ctrl *gomock.Controller) *MockQuerier <span class="cov0" title="0">{
        mock := &amp;MockQuerier{ctrl: ctrl}
        mock.recorder = &amp;MockQuerierMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQuerier) EXPECT() *MockQuerierMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateOrder mocks base method.
func (m *MockQuerier) CreateOrder(ctx context.Context, arg db.CreateOrderParams) (db.Order, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateOrder", ctx, arg)
        ret0, _ := ret[0].(db.Order)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateOrder indicates an expected call of CreateOrder.
func (mr *MockQuerierMockRecorder) CreateOrder(ctx, arg any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrder", reflect.TypeOf((*MockQuerier)(nil).CreateOrder), ctx, arg)
}</span>

// GetOrder mocks base method.
func (m *MockQuerier) GetOrder(ctx context.Context, id int32) (db.Order, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetOrder", ctx, id)
        ret0, _ := ret[0].(db.Order)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetOrder indicates an expected call of GetOrder.
func (mr *MockQuerierMockRecorder) GetOrder(ctx, id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrder", reflect.TypeOf((*MockQuerier)(nil).GetOrder), ctx, id)
}</span>

// ListOrders mocks base method.
func (m *MockQuerier) ListOrders(ctx context.Context, arg db.ListOrdersParams) ([]db.Order, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListOrders", ctx, arg)
        ret0, _ := ret[0].([]db.Order)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListOrders indicates an expected call of ListOrders.
func (mr *MockQuerierMockRecorder) ListOrders(ctx, arg any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListOrders", reflect.TypeOf((*MockQuerier)(nil).ListOrders), ctx, arg)
}</span>

// UpdateOrderStatus mocks base method.
func (m *MockQuerier) UpdateOrderStatus(ctx context.Context, arg db.UpdateOrderStatusParams) (db.Order, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateOrderStatus", ctx, arg)
        ret0, _ := ret[0].(db.Order)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateOrderStatus indicates an expected call of UpdateOrderStatus.
func (mr *MockQuerierMockRecorder) UpdateOrderStatus(ctx, arg any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateOrderStatus", reflect.TypeOf((*MockQuerier)(nil).UpdateOrderStatus), ctx, arg)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package db

import (
        "context"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
        Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
        Query(context.Context, string, ...interface{}) (pgx.Rows, error)
        QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries <span class="cov10" title="27">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package db

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
)

// DBStore defines all functions to execute db queries and transactions
type DBStore interface {
        Querier
        CancelOrderTx(ctx context.Context, orderId int, logFields slog.Attr) (int, error)
        ValidateAndUpdateOrderStatusTx(ctx context.Context, id int, expectedCurrentStatus OrderStatus, newStatus OrderStatus, logFields slog.Attr) (orderId int, err error)
}

// SQLStore is the real implementation of querier that sqlc generated from migration script (in order to differentiate with mock one)
type SQLStore struct {
        *Queries
        db *pgxpool.Pool
}

func NewStore(db *pgxpool.Pool) DBStore <span class="cov1" title="1">{
        return &amp;SQLStore{
                db:      db,
                Queries: New(db),
        }
}</span>

func (store *SQLStore) execTx(ctx context.Context, fn func(*Queries) error) error <span class="cov10" title="25">{
        tx, err := store.db.BeginTx(ctx,
                pgx.TxOptions{
                        IsoLevel: pgx.RepeatableRead,
                })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // New is provided by SQLC
        <span class="cov10" title="25">q := New(tx)

        // Catch the error of a transaction
        err = fn(q)
        if err != nil </span><span class="cov9" title="21">{
                if rbErr := tx.Rollback(ctx); rbErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("tx err: %v, rb err: %v", err, rbErr)
                }</span>
                <span class="cov9" title="21">return err</span>
        }

        <span class="cov4" title="4">return tx.Commit(ctx)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package db

import (
        "database/sql/driver"
        "fmt"

        "github.com/jackc/pgx/v5/pgtype"
)

type OrderStatus string

const (
        OrderStatusCreated             OrderStatus = "created"
        OrderStatusPendingPayment      OrderStatus = "pendingPayment"
        OrderStatusAwaitingPayment     OrderStatus = "awaitingPayment"
        OrderStatusAwaitingFulfillment OrderStatus = "awaitingFulfillment"
        OrderStatusFailed              OrderStatus = "failed"
        OrderStatusRefunded            OrderStatus = "refunded"
        OrderStatusCancelled           OrderStatus = "cancelled"
        OrderStatusFinished            OrderStatus = "finished"
)

func (e *OrderStatus) Scan(src interface{}) error <span class="cov10" title="45">{
        switch s := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                *e = OrderStatus(s)</span>
        case string:<span class="cov10" title="45">
                *e = OrderStatus(s)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported scan type for OrderStatus: %T", src)</span>
        }
        <span class="cov10" title="45">return nil</span>
}

type NullOrderStatus struct {
        OrderStatus OrderStatus `json:"order_status"`
        Valid       bool        `json:"valid"` // Valid is true if OrderStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOrderStatus) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                ns.OrderStatus, ns.Valid = "", false
                return nil
        }</span>
        <span class="cov0" title="0">ns.Valid = true
        return ns.OrderStatus.Scan(value)</span>
}

// Value implements the driver Valuer interface.
func (ns NullOrderStatus) Value() (driver.Value, error) <span class="cov0" title="0">{
        if !ns.Valid </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return string(ns.OrderStatus), nil</span>
}

func (e OrderStatus) Valid() bool <span class="cov2" title="2">{
        switch e </span>{
        case OrderStatusCreated,
                OrderStatusPendingPayment,
                OrderStatusAwaitingPayment,
                OrderStatusAwaitingFulfillment,
                OrderStatusFailed,
                OrderStatusRefunded,
                OrderStatusCancelled,
                OrderStatusFinished:<span class="cov1" title="1">
                return true</span>
        }
        <span class="cov1" title="1">return false</span>
}

func AllOrderStatusValues() []OrderStatus <span class="cov1" title="1">{
        return []OrderStatus{
                OrderStatusCreated,
                OrderStatusPendingPayment,
                OrderStatusAwaitingPayment,
                OrderStatusAwaitingFulfillment,
                OrderStatusFailed,
                OrderStatusRefunded,
                OrderStatusCancelled,
                OrderStatusFinished,
        }
}</span>

type Order struct {
        ID int32 `db:"id" json:"id"`
        // random value, not used now
        UserID string         `db:"user_id" json:"user_id"`
        Status OrderStatus    `db:"status" json:"status"`
        Amount pgtype.Numeric `db:"amount" json:"amount"`
        // for failed reason
        Message   *string            `db:"message" json:"message"`
        CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
        UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: orders.sql

package db

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
  user_id,
  status,
  amount,
  message
) VALUES (
  $1, $2, $3, $4
) RETURNING id, user_id, status, amount, message, created_at, updated_at
`

type CreateOrderParams struct {
        UserID  string         `db:"user_id" json:"user_id"`
        Status  OrderStatus    `db:"status" json:"status"`
        Amount  pgtype.Numeric `db:"amount" json:"amount"`
        Message *string        `db:"message" json:"message"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) <span class="cov6" title="9">{
        row := q.db.QueryRow(ctx, createOrder,
                arg.UserID,
                arg.Status,
                arg.Amount,
                arg.Message,
        )
        var i Order
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.Status,
                &amp;i.Amount,
                &amp;i.Message,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const getOrder = `-- name: GetOrder :one
SELECT id, user_id, status, amount, message, created_at, updated_at FROM orders
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOrder(ctx context.Context, id int32) (Order, error) <span class="cov10" title="29">{
        row := q.db.QueryRow(ctx, getOrder, id)
        var i Order
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.Status,
                &amp;i.Amount,
                &amp;i.Message,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const listOrders = `-- name: ListOrders :many
SELECT id, user_id, status, amount, message, created_at, updated_at FROM orders
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListOrdersParams struct {
        Limit  int32 `db:"limit" json:"limit"`
        Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListOrders(ctx context.Context, arg ListOrdersParams) ([]Order, error) <span class="cov1" title="1">{
        rows, err := q.db.Query(ctx, listOrders, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer rows.Close()
        items := []Order{}
        for rows.Next() </span><span class="cov3" title="3">{
                var i Order
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.UserID,
                        &amp;i.Status,
                        &amp;i.Amount,
                        &amp;i.Message,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov3" title="3">items = append(items, i)</span>
        }
        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return items, nil</span>
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE orders
  set status = $2
WHERE id = $1
RETURNING id, user_id, status, amount, message, created_at, updated_at
`

type UpdateOrderStatusParams struct {
        ID     int32       `db:"id" json:"id"`
        Status OrderStatus `db:"status" json:"status"`
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error) <span class="cov5" title="5">{
        row := q.db.QueryRow(ctx, updateOrderStatus, arg.ID, arg.Status)
        var i Order
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.Status,
                &amp;i.Amount,
                &amp;i.Message,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package db

import (
        "context"
        "errors"
        "log/slog"

        "github.com/TrungTho/saga-playground/constants"
)

func (store *SQLStore) CancelOrderTx(ctx context.Context, id int, logFields slog.Attr) (orderId int, err error) <span class="cov9" title="20">{
        return store.ValidateAndUpdateOrderStatusTx(ctx, id, OrderStatusCreated, OrderStatusCancelled, logFields)
}</span>

// this function will help to update status of order,
// but it will check the current status of that order first to make sure it's in accepted status before making the change
// Parameters:
//   - id: id of the order
//   - expectedCurrentStatus: the current status of order which we are expecting it is (for state machine check)
//   - newStatus: the new status of order that we would like to update it to (if the above status is correct)
//
// Returns:
//   - id: id of the updated order
//   - err: error (in case expectedCurrentStatus does not match the actual status of order in db record, or transaction error, etc.)
func (store *SQLStore) ValidateAndUpdateOrderStatusTx(ctx context.Context, id int, expectedCurrentStatus OrderStatus, newStatus OrderStatus, logFields slog.Attr) (orderId int, err error) <span class="cov10" title="25">{
        err = store.execTx(ctx, func(q *Queries) error </span><span class="cov10" title="25">{
                order, err := q.GetOrder(ctx, int32(id)) // NOTICE: q, the querier which was init inside the transaction, NOT THE store.Querier.GetOrder(), otherwise the go-routine will be blocked forever
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov9" title="24">if order.Status != expectedCurrentStatus </span><span class="cov9" title="20">{
                        slog.ErrorContext(ctx,
                                constants.ERROR_ORDER_INVALID_STATUS, logFields,
                                slog.String("current_status", string(order.Status)),
                                slog.String("expected_current_status", string(expectedCurrentStatus)),
                        )
                        return errors.New(constants.INVALID_ACTION)
                }</span>

                <span class="cov4" title="4">_, err = q.UpdateOrderStatus(ctx,
                        UpdateOrderStatusParams{ID: order.ID, Status: newStatus})
                if err != nil </span><span class="cov0" title="0">{
                        slog.ErrorContext(ctx, constants.ERROR_ORDER_UPDATE_FAILED,
                                logFields,
                                slog.String("current_status", string(order.Status)),
                                slog.String("new_status", string(newStatus)),
                                slog.String("expected_current_status", string(expectedCurrentStatus)),
                                slog.Any("error", err),
                        )
                        return err
                }</span>

                <span class="cov4" title="4">return nil</span>
        })
        <span class="cov10" title="25">if err != nil </span><span class="cov9" title="21">{
                return -1, err
        }</span>

        <span class="cov4" title="4">return int(id), nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package db

import (
        "context"
        "fmt"
        "log"

        "github.com/TrungTho/saga-playground/util"
        "github.com/golang-migrate/migrate/v4"
        _ "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        "github.com/jackc/pgx/v5/pgxpool"
)

func SetupDBConnection(config *util.Config) (DBStore, *pgxpool.Pool) <span class="cov8" title="1">{
        // set up db connection
        dbSource := fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable",
                config.DB_USER, config.DB_PASSWORD, config.DB_HOST, config.DB_PORT, config.ORDER_DB_NAME)
        testDB, err := pgxpool.New(context.Background(), dbSource)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Can not connect to the db: ", err)
        }</span>

        // try to start migration up process
        <span class="cov8" title="1">m, err := migrate.New(config.ORDER_MIGRATION_FILE, dbSource)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Can not set up connection for db migration", err)
        }</span>

        <span class="cov8" title="1">if err = m.Up(); err != nil &amp;&amp; err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                log.Fatal("Can not migrate db successfully", err)
        }</span>

        // return connected &amp; migrated db connection
        <span class="cov8" title="1">return NewStore(testDB), testDB</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package grpc_server

import (
        "context"
        "log/slog"

        "github.com/TrungTho/saga-playground/constants"
        db "github.com/TrungTho/saga-playground/db/sqlc"
        "github.com/TrungTho/saga-playground/pb"
)

func (server GRPCServer) SwitchOrderToPendingPayment(ctx context.Context, req *pb.SwitchToPendingPaymentRequest) (*pb.SwitchToPendingPaymentResponse, error) <span class="cov10" title="2">{
        logFields := slog.Group("rpc",
                slog.String("method", "SwitchOrderToPendingPayment"),
                slog.Any("request", req),
        )

        // call db transaction for check and update status to pending payment
        orderId, err := server.dbStore.ValidateAndUpdateOrderStatusTx(ctx, int(req.Id), db.OrderStatusCreated, db.OrderStatusPendingPayment, logFields)
        // return successful or failed status
        if err != nil </span><span class="cov1" title="1">{
                slog.ErrorContext(ctx, constants.ERROR_ORDER_RPC_START_PAYMENT, logFields, slog.Any("error", err))

                return nil, err
        }</span>

        <span class="cov1" title="1">slog.InfoContext(ctx, constants.ORDER_STATUS_CHANGED, logFields, slog.String(
                "new_status", string(db.OrderStatusPendingPayment),
        ))

        return &amp;pb.SwitchToPendingPaymentResponse{
                Order: &amp;pb.Order{
                        Id:     int32(orderId),
                        Status: string(db.OrderStatusPendingPayment),
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package grpc_server

import (
        db "github.com/TrungTho/saga-playground/db/sqlc"
        "github.com/TrungTho/saga-playground/pb"
)

type GRPCServer struct {
        // config    util.Config // just in case we need to use it in the future
        dbStore db.DBStore
        pb.UnimplementedOrderServiceServer
}

// NewServer creates a new HTTP server and set up routing.
func NewServer(dbStore db.DBStore) (*GRPCServer, error) <span class="cov10" title="2">{
        server := &amp;GRPCServer{
                dbStore: dbStore,
        }

        return server, nil
}</span>

// Start runs the HTTP server on a specific address.
func (server *GRPCServer) Start(address string) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package logger

import (
        "log/slog"
        "os"
)

func InitLogger() <span class="cov0" title="0">{
        logger := slog.New(slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level:     slog.LevelDebug,
                AddSource: true, // location of log line
        }))

        slog.SetDefault(logger)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.2
//         protoc        v5.29.2
// source: order.proto

package pb

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Order struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            int32                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`        // order id
        Status        string                 `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"` //order status
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Order) Reset() <span class="cov0" title="0">{
        *x = Order{}
        mi := &amp;file_order_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Order) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Order) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Order) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_order_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Order.ProtoReflect.Descriptor instead.
func (*Order) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_order_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Order) GetId() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Order) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// request to swich order status to OrderStatusPendingPayment and prevent any further cancelling request from user
type SwitchToPendingPaymentRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            int32                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"` // order id
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SwitchToPendingPaymentRequest) Reset() <span class="cov0" title="0">{
        *x = SwitchToPendingPaymentRequest{}
        mi := &amp;file_order_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SwitchToPendingPaymentRequest) String() string <span class="cov5" title="2">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SwitchToPendingPaymentRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SwitchToPendingPaymentRequest) ProtoReflect() protoreflect.Message <span class="cov10" title="4">{
        mi := &amp;file_order_proto_msgTypes[1]
        if x != nil </span><span class="cov10" title="4">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov5" title="2">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov10" title="4">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SwitchToPendingPaymentRequest.ProtoReflect.Descriptor instead.
func (*SwitchToPendingPaymentRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_order_proto_rawDescGZIP(), []int{1}
}</span>

func (x *SwitchToPendingPaymentRequest) GetId() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type SwitchToPendingPaymentResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Order         *Order                 `protobuf:"bytes,1,opt,name=order,proto3" json:"order,omitempty"` // return the updated order
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SwitchToPendingPaymentResponse) Reset() <span class="cov0" title="0">{
        *x = SwitchToPendingPaymentResponse{}
        mi := &amp;file_order_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SwitchToPendingPaymentResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SwitchToPendingPaymentResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SwitchToPendingPaymentResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_order_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SwitchToPendingPaymentResponse.ProtoReflect.Descriptor instead.
func (*SwitchToPendingPaymentResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_order_proto_rawDescGZIP(), []int{2}
}</span>

func (x *SwitchToPendingPaymentResponse) GetOrder() *Order <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Order
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_order_proto protoreflect.FileDescriptor

var file_order_proto_rawDesc = []byte{
        0x0a, 0x0b, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x08, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x22, 0x2f, 0x0a, 0x05, 0x4f, 0x72, 0x64, 0x65, 0x72,
        0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x69, 0x64,
        0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x2f, 0x0a, 0x1d, 0x53, 0x77, 0x69, 0x74,
        0x63, 0x68, 0x54, 0x6f, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x50, 0x61, 0x79, 0x6d, 0x65,
        0x6e, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x69, 0x64, 0x22, 0x47, 0x0a, 0x1e, 0x53, 0x77, 0x69,
        0x74, 0x63, 0x68, 0x54, 0x6f, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x50, 0x61, 0x79, 0x6d,
        0x65, 0x6e, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x25, 0x0a, 0x05, 0x6f,
        0x72, 0x64, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x52, 0x05, 0x6f, 0x72, 0x64,
        0x65, 0x72, 0x32, 0x80, 0x01, 0x0a, 0x0c, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x53, 0x65, 0x72, 0x76,
        0x69, 0x63, 0x65, 0x12, 0x70, 0x0a, 0x1b, 0x53, 0x77, 0x69, 0x74, 0x63, 0x68, 0x4f, 0x72, 0x64,
        0x65, 0x72, 0x54, 0x6f, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x50, 0x61, 0x79, 0x6d, 0x65,
        0x6e, 0x74, 0x12, 0x27, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53, 0x77,
        0x69, 0x74, 0x63, 0x68, 0x54, 0x6f, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x50, 0x61, 0x79,
        0x6d, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x28, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53, 0x77, 0x69, 0x74, 0x63, 0x68, 0x54, 0x6f, 0x50,
        0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x50, 0x61, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x06, 0x5a, 0x04, 0x2e, 0x2f, 0x70, 0x62, 0x62, 0x06, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_order_proto_rawDescOnce sync.Once
        file_order_proto_rawDescData = file_order_proto_rawDesc
)

func file_order_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_order_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_order_proto_rawDescData = protoimpl.X.CompressGZIP(file_order_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_order_proto_rawDescData</span>
}

var file_order_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_order_proto_goTypes = []any{
        (*Order)(nil),                          // 0: protobuf.Order
        (*SwitchToPendingPaymentRequest)(nil),  // 1: protobuf.SwitchToPendingPaymentRequest
        (*SwitchToPendingPaymentResponse)(nil), // 2: protobuf.SwitchToPendingPaymentResponse
}
var file_order_proto_depIdxs = []int32{
        0, // 0: protobuf.SwitchToPendingPaymentResponse.order:type_name -&gt; protobuf.Order
        1, // 1: protobuf.OrderService.SwitchOrderToPendingPayment:input_type -&gt; protobuf.SwitchToPendingPaymentRequest
        2, // 2: protobuf.OrderService.SwitchOrderToPendingPayment:output_type -&gt; protobuf.SwitchToPendingPaymentResponse
        2, // [2:3] is the sub-list for method output_type
        1, // [1:2] is the sub-list for method input_type
        1, // [1:1] is the sub-list for extension type_name
        1, // [1:1] is the sub-list for extension extendee
        0, // [0:1] is the sub-list for field type_name
}

func init() <span class="cov1" title="1">{ file_order_proto_init() }</span>
func file_order_proto_init() <span class="cov1" title="1">{
        if File_order_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_order_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   3,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_order_proto_goTypes,
                DependencyIndexes: file_order_proto_depIdxs,
                MessageInfos:      file_order_proto_msgTypes,
        }.Build()
        File_order_proto = out.File
        file_order_proto_rawDesc = nil
        file_order_proto_goTypes = nil
        file_order_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.2
// source: order.proto

package pb

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        OrderService_SwitchOrderToPendingPayment_FullMethodName = "/protobuf.OrderService/SwitchOrderToPendingPayment"
)

// OrderServiceClient is the client API for OrderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OrderServiceClient interface {
        SwitchOrderToPendingPayment(ctx context.Context, in *SwitchToPendingPaymentRequest, opts ...grpc.CallOption) (*SwitchToPendingPaymentResponse, error)
}

type orderServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewOrderServiceClient(cc grpc.ClientConnInterface) OrderServiceClient <span class="cov0" title="0">{
        return &amp;orderServiceClient{cc}
}</span>

func (c *orderServiceClient) SwitchOrderToPendingPayment(ctx context.Context, in *SwitchToPendingPaymentRequest, opts ...grpc.CallOption) (*SwitchToPendingPaymentResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(SwitchToPendingPaymentResponse)
        err := c.cc.Invoke(ctx, OrderService_SwitchOrderToPendingPayment_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// OrderServiceServer is the server API for OrderService service.
// All implementations must embed UnimplementedOrderServiceServer
// for forward compatibility.
type OrderServiceServer interface {
        SwitchOrderToPendingPayment(context.Context, *SwitchToPendingPaymentRequest) (*SwitchToPendingPaymentResponse, error)
        mustEmbedUnimplementedOrderServiceServer()
}

// UnimplementedOrderServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedOrderServiceServer struct{}

func (UnimplementedOrderServiceServer) SwitchOrderToPendingPayment(context.Context, *SwitchToPendingPaymentRequest) (*SwitchToPendingPaymentResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SwitchOrderToPendingPayment not implemented")
}</span>
func (UnimplementedOrderServiceServer) mustEmbedUnimplementedOrderServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedOrderServiceServer) testEmbeddedByValue()                      {<span class="cov0" title="0">}</span>

// UnsafeOrderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OrderServiceServer will
// result in compilation errors.
type UnsafeOrderServiceServer interface {
        mustEmbedUnimplementedOrderServiceServer()
}

func RegisterOrderServiceServer(s grpc.ServiceRegistrar, srv OrderServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedOrderServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;OrderService_ServiceDesc, srv)</span>
}

func _OrderService_SwitchOrderToPendingPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(SwitchToPendingPaymentRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OrderServiceServer).SwitchOrderToPendingPayment(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OrderService_SwitchOrderToPendingPayment_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OrderServiceServer).SwitchOrderToPendingPayment(ctx, req.(*SwitchToPendingPaymentRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// OrderService_ServiceDesc is the grpc.ServiceDesc for OrderService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OrderService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "protobuf.OrderService",
        HandlerType: (*OrderServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "SwitchOrderToPendingPayment",
                        Handler:    _OrderService_SwitchOrderToPendingPayment_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "order.proto",
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package redis

import (
        "context"
        "fmt"
        "log"
        "log/slog"
        "time"

        "github.com/TrungTho/saga-playground/util"
        "github.com/bsm/redislock"
        "github.com/redis/go-redis/v9"
)

type RedisStore struct {
        redisClient *redis.Client
        locker      *redislock.Client
}

func NewRedisWrapper(config util.Config) *RedisStore <span class="cov0" title="0">{
        rdb := redis.NewClient(&amp;redis.Options{
                Addr:            fmt.Sprintf("%s:%s", config.REDIS_HOST, config.REDIS_PORT),
                Password:        config.REDIS_PASSWORD,
                DB:              config.REDIS_DB,
                PoolSize:        10,
                MinIdleConns:    2,
                ConnMaxIdleTime: 5 * time.Minute,
        })

        _, err := rdb.Ping(context.Background()).Result()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to ping redis", err)
        }</span>

        <span class="cov0" title="0">locker := redislock.New(rdb)
        if locker == nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to init distributed lock", err)
        }</span>

        <span class="cov0" title="0">return &amp;RedisStore{
                redisClient: rdb,
                locker:      locker,
        }</span>
}

func (r RedisStore) TryAcquireLock(ctx context.Context, key string, ttl time.Duration) *redislock.Lock <span class="cov0" title="0">{
        lock, err := r.locker.Obtain(ctx, key, ttl, nil)
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "Failed to acquire lock", slog.Any("error", err))
                return nil
        }</span>

        <span class="cov0" title="0">return lock</span>
}

func (r RedisStore) ReleaseLock(ctx context.Context, lock *redislock.Lock) <span class="cov0" title="0">{
        if lock != nil </span><span class="cov0" title="0">{
                lock.Release(ctx)
        }</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package util

import (
        "fmt"

        "github.com/spf13/viper"
)

// Config stores all configuration of the application.
// The values are read by viper from a config file or environment variable.
type Config struct {
        ENV string `mapstructure:"ENV"`

        DB_PASSWORD string `mapstructure:"DB_PASSWORD"`
        DB_HOST     string `mapstructure:"DB_HOST"`
        DB_USER     string `mapstructure:"DB_USER"`
        DB_DRIVER   string `mapstructure:"DB_DRIVER"`
        DB_PORT     string `mapstructure:"DB_PORT"`

        ORDER_DB_NAME           string `mapstructure:"ORDER_DB_NAME"`
        ORDER_SERVICE_PORT      string `mapstructure:"ORDER_SERVICE_PORT"`
        ORDER_SERVICE_GRPC_PORT string `mapstructure:"ORDER_SERVICE_GRPC_PORT"`
        ORDER_SERVICE_HOST      string `mapstructure:"ORDER_SERVICE_HOST"`
        ORDER_MIGRATION_FILE    string `mapstructure:"ORDER_MIGRATION_FILE"`

        REDIS_HOST     string `mapstructure:"REDIS_HOST"`
        REDIS_PORT     string `mapstructure:"REDIS_PORT"`
        REDIS_PASSWORD string `mapstructure:"REDIS_PASSWORD"`
        REDIS_DB       int    `mapstructure:"REDIS_DB"`
}

// LoadConfig reads configuration from file or environment variables.
func LoadConfig(path string) (config Config, err error) <span class="cov10" title="2">{
        viper.SetConfigFile(path)

        viper.AutomaticEnv()

        err = viper.ReadInConfig()
        if err != nil </span><span class="cov1" title="1">{
                panic(fmt.Errorf("fatal error config file: %w", err))</span>
        }

        <span class="cov1" title="1">err = viper.Unmarshal(&amp;config)
        return</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package util

import (
        "math/rand"
        "time"
)

const alphabet = "abcdefghijklmnopqrstuvwxyz"

var r *rand.Rand

func init() <span class="cov1" title="1">{
        r = rand.New(rand.NewSource(time.Now().UnixNano()))
}</span>

// RandomInt generates a random integer between min and max
func RandomInt(min, max int64) int64 <span class="cov10" title="100">{
        return min + r.Int63n(max-min+1)
}</span>

func RandomFloat(upperBound int) float64 <span class="cov4" title="5">{
        return float64(upperBound) * r.Float64()
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package util

import (
        "bytes"
        "encoding/json"
        "io"
        "testing"

        "github.com/stretchr/testify/require"
)

func ConvertStructToByte(t *testing.T, body interface{}) *bytes.Buffer <span class="cov10" title="2">{
        res, err := json.Marshal(body)
        require.NoError(t, err, "Should be able to convert body")
        return bytes.NewBuffer(res)
}</span>

func ConvertByteToStruct(t *testing.T, body *bytes.Buffer, gotValue interface{}) <span class="cov1" title="1">{
        data, err := io.ReadAll(body)
        require.NoError(t, err, "Cannot parse body data")

        err = json.Unmarshal(data, &amp;gotValue)
        require.NoError(t, err, "Cannot parse json string to struct")
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package subscriber

import (
        "log/slog"

        "github.com/go-faker/faker/v4"
)

func (s Subscriber) PullSuccessfulCheckoutMessage() <span class="cov0" title="0">{
        runId := faker.UUIDDigit()
        logFields := slog.Group("worker",
                slog.String("name", "PullSuccessfulCheckoutMessage"),
                slog.String("runId", runId),
        )
        // ctx := context.Background()
        slog.Info("JOB START", logFields)

        // pull all records from kafka (do we need limit here?)

        // bulk insert to db

        // ack

        slog.Info("JOB END", logFields)
}</span>

// todo: worker for processing record
// todo: worker for deleting already-processed records before 3 days ago
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
